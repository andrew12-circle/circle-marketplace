-- Create advisor_responses table for storing individual question answers
CREATE TABLE public.advisor_responses (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL,
  question_id TEXT NOT NULL,
  value JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create advisor_signals table for normalized signals derived from responses
CREATE TABLE public.advisor_signals (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL,
  signal TEXT NOT NULL,
  value TEXT NOT NULL,
  weight NUMERIC DEFAULT 1,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Create consultation_bookings table for human advisor fallback
CREATE TABLE public.consultation_bookings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL,
  contact TEXT NOT NULL,
  notes TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- Add columns to existing goal_based_recommendations table
ALTER TABLE public.goal_based_recommendations ADD COLUMN IF NOT EXISTS accepted_at TIMESTAMP WITH TIME ZONE;
ALTER TABLE public.goal_based_recommendations ADD COLUMN IF NOT EXISTS dismissed_at TIMESTAMP WITH TIME ZONE;
ALTER TABLE public.goal_based_recommendations ADD COLUMN IF NOT EXISTS dismiss_reason TEXT;
ALTER TABLE public.goal_based_recommendations ADD COLUMN IF NOT EXISTS playbook_key TEXT;
ALTER TABLE public.goal_based_recommendations ADD COLUMN IF NOT EXISTS rec_skus JSONB DEFAULT '[]'::jsonb;
ALTER TABLE public.goal_based_recommendations ADD COLUMN IF NOT EXISTS reasons JSONB DEFAULT '{}'::jsonb;
ALTER TABLE public.goal_based_recommendations ADD COLUMN IF NOT EXISTS roi JSONB DEFAULT '{}'::jsonb;

-- Enable RLS on new tables
ALTER TABLE public.advisor_responses ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.advisor_signals ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.consultation_bookings ENABLE ROW LEVEL SECURITY;

-- RLS policies for advisor_responses
CREATE POLICY "Users can manage their own advisor responses" ON public.advisor_responses
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- RLS policies for advisor_signals
CREATE POLICY "Users can manage their own advisor signals" ON public.advisor_signals
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- RLS policies for consultation_bookings
CREATE POLICY "Users can manage their own consultation bookings" ON public.consultation_bookings
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- Admin policies for all tables
CREATE POLICY "Admins can view all advisor responses" ON public.advisor_responses
  FOR SELECT USING (get_user_admin_status());

CREATE POLICY "Admins can view all advisor signals" ON public.advisor_signals
  FOR SELECT USING (get_user_admin_status());

CREATE POLICY "Admins can view all consultation bookings" ON public.consultation_bookings
  FOR SELECT USING (get_user_admin_status());

-- Create trigger for updated_at on advisor_responses
CREATE OR REPLACE FUNCTION public.update_advisor_responses_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_advisor_responses_updated_at
  BEFORE UPDATE ON public.advisor_responses
  FOR EACH ROW
  EXECUTE FUNCTION public.update_advisor_responses_updated_at();